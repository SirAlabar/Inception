name: Inception Docker Tests

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Debug repository structure
        run: |
          echo "Current directory: $(pwd)"
          echo "Repository files:"
          ls -la
          echo "Directory structure:"
          find . -type f -name "Makefile" | sort
          find . -type f -name "docker-compose.yml" | sort
          find . -type d -name "srcs" | sort
          find . -type f -name ".env" | sort

      - name: Create required directories for volumes
        run: |
          sudo mkdir -p ${HOME}/data/mariadb
          sudo mkdir -p ${HOME}/data/wordpress
          sudo mkdir -p ${HOME}/data/adminer
          sudo mkdir -p ${HOME}/data/portainer
          sudo mkdir -p ${HOME}/data/redis
          sudo chmod -R 777 ${HOME}/data/

      - name: Create test secrets
        run: |
          # We'll use default values for testing
          mkdir -p secrets
          echo "localhost" > secrets/domain_name.txt
          echo "wpuser" > secrets/db_user.txt
          echo "wppassword" > secrets/db_password.txt
          echo "rootpassword" > secrets/db_root_password.txt
          echo "superadmin" > secrets/wp_admin_user.txt
          echo "adminpassword" > secrets/wp_admin_password.txt
          echo "admin@example.com" > secrets/wp_admin_email.txt
          echo "regularuser" > secrets/wp_user.txt
          echo "userpassword" > secrets/wp_user_password.txt
          echo "user@example.com" > secrets/wp_user_email.txt
          echo "wpftp" > secrets/ftp_user.txt
          echo "ftppassword" > secrets/ftp_password.txt
          echo "redispassword" > secrets/redis_password.txt

      - name: Setup Docker
        uses: docker/setup-buildx-action@v2

      - name: Build and start containers
        run: |
          echo "Current directory: $(pwd)"
          echo "Building and starting containers with docker compose:"
          
          # Find the correct path to docker-compose.yml
          COMPOSE_FILE=$(find . -type f -name "docker-compose.yml" | head -1)
          ENV_FILE=$(find . -type f -name ".env" | head -1)
          
          if [ -z "$COMPOSE_FILE" ]; then
            echo "‚ùå docker-compose.yml not found in repository!"
            exit 1
          fi
          
          echo "Using docker-compose file: $COMPOSE_FILE"
          echo "Using env file: $ENV_FILE"
          
          if [ -n "$ENV_FILE" ]; then
            docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" up -d --build
          else
            docker compose -f "$COMPOSE_FILE" up -d --build
          fi
          
          echo "Waiting for containers to initialize (60 seconds)..."
          sleep 60  # Give containers time to start

      - name: Check running containers
        run: |
          echo "Docker containers status:"
          docker ps

      - name: Display container logs
        run: |
          echo "=== WordPress Container Logs ==="
          docker logs wordpress || true
          
          echo "=== MariaDB Container Logs ==="
          docker logs mariadb || true
          
          echo "=== NGINX Container Logs ==="
          docker logs nginx || true
          
          echo "=== Redis Container Logs ==="
          docker logs redis || true
          
          echo "=== Adminer Container Logs ==="
          docker logs adminer || true
          
          echo "=== FTP Container Logs ==="
          docker logs ftp || true
          
          echo "=== Portainer Container Logs ==="
          docker logs portainer || true

      - name: Test MariaDB container
        run: |
          MARIADB_CONTAINER_ID=$(docker ps -q --filter "name=mariadb")
          if [ -z "$MARIADB_CONTAINER_ID" ]; then
            echo "‚ùå MariaDB container is not running"
            exit 1
          fi
          
          echo "‚úÖ MariaDB container is running"
          
          # Check health status (if available)
          HEALTH_STATUS=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}not-supported{{end}}' $MARIADB_CONTAINER_ID)
          if [ "$HEALTH_STATUS" != "not-supported" ] && [ "$HEALTH_STATUS" != "healthy" ]; then
            echo "‚ö†Ô∏è MariaDB container has unhealthy status: $HEALTH_STATUS"
            docker logs $MARIADB_CONTAINER_ID
          else
            echo "‚úÖ MariaDB health check passed"
          fi
          
          # Use default values for testing
          docker exec mariadb mysql -uroot -prootpassword -e "SHOW DATABASES;" || {
            echo "‚ùå Failed to connect to MariaDB with root credentials"
            exit 1
          }
          
          # Try with regular user credentials
          docker exec mariadb mysql -uwpuser -pwppassword -e "SHOW DATABASES;" | grep wordpress || {
            echo "‚ö†Ô∏è Failed to connect to MariaDB with regular user credentials"
          }
          
          echo "‚úÖ Successfully connected to MariaDB"

      - name: Test WordPress container
        run: |
          WP_CONTAINER_ID=$(docker ps -q --filter "name=wordpress")
          if [ -z "$WP_CONTAINER_ID" ]; then
            echo "‚ùå WordPress container is not running"
            exit 1
          fi
          
          echo "‚úÖ WordPress container is running"
          
          # Check health status (if available)
          HEALTH_STATUS=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}not-supported{{end}}' $WP_CONTAINER_ID)
          if [ "$HEALTH_STATUS" != "not-supported" ] && [ "$HEALTH_STATUS" != "healthy" ]; then
            echo "‚ö†Ô∏è WordPress container has unhealthy status: $HEALTH_STATUS"
          else
            echo "‚úÖ WordPress health check passed"
          fi
          
          # Check if PHP-FPM is running
          if ! docker exec $WP_CONTAINER_ID pgrep php-fpm > /dev/null; then
            echo "‚ùå PHP-FPM is not running in WordPress container"
            exit 1
          fi
          
          echo "‚úÖ PHP-FPM is running in WordPress container"
          
          # Check if wp-config.php exists
          if ! docker exec $WP_CONTAINER_ID test -f /var/www/html/wp-config.php; then
            echo "‚ùå wp-config.php file is missing in WordPress container"
            exit 1
          fi
          
          echo "‚úÖ WordPress configuration file exists"
          
          # Show WordPress file structure
          echo "WordPress directory content:"
          docker exec $WP_CONTAINER_ID ls -la /var/www/html/ || true

      - name: Test NGINX container
        run: |
          NGINX_CONTAINER_ID=$(docker ps -q --filter "name=nginx")
          if [ -z "$NGINX_CONTAINER_ID" ]; then
            echo "‚ùå NGINX container is not running"
            exit 1
          fi
          
          echo "‚úÖ NGINX container is running"
          
          # Check health status (if available)
          HEALTH_STATUS=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}not-supported{{end}}' $NGINX_CONTAINER_ID)
          if [ "$HEALTH_STATUS" != "not-supported" ] && [ "$HEALTH_STATUS" != "healthy" ]; then
            echo "‚ö†Ô∏è NGINX container has unhealthy status: $HEALTH_STATUS"
          else
            echo "‚úÖ NGINX health check passed"
          fi
          
          # Check if NGINX is running
          if ! docker exec $NGINX_CONTAINER_ID pgrep nginx > /dev/null; then
            echo "‚ùå NGINX process is not running"
            exit 1
          fi
          
          echo "‚úÖ NGINX process is running"
          
          # Check if SSL certificate exists
          if ! docker exec $NGINX_CONTAINER_ID test -f /etc/nginx/ssl/nginx.crt; then
            echo "‚ö†Ô∏è SSL certificate not found at default location"
            echo "Searching for SSL certificates:"
            docker exec $NGINX_CONTAINER_ID find /etc -name "*.crt" || true
            docker exec $NGINX_CONTAINER_ID find /etc -name "*.key" || true
          else
            echo "‚úÖ SSL certificate exists"
          fi
          
          # Check NGINX configuration
          echo "NGINX configuration:"
          docker exec $NGINX_CONTAINER_ID nginx -T || true

      - name: Test Redis container
        run: |
          REDIS_CONTAINER_ID=$(docker ps -q --filter "name=redis")
          if [ -z "$REDIS_CONTAINER_ID" ]; then
            echo "‚ùå Redis container is not running"
            exit 1
          fi
          
          echo "‚úÖ Redis container is running"
          
          # Check if Redis is running
          if ! docker exec $REDIS_CONTAINER_ID pgrep redis-server > /dev/null; then
            echo "‚ùå Redis server process is not running"
            exit 1
          fi
          
          echo "‚úÖ Redis server process is running"
          
          # Extract the REDIS_PASSWORD from the .env file
          ENV_FILE=$(find . -type f -name ".env" | head -1)
          REDIS_PASSWORD=$(grep REDIS_PASSWORD $ENV_FILE | cut -d= -f2)
          
          echo "üîë Attempting Redis connection with password from .env file"
          if docker exec $REDIS_CONTAINER_ID redis-cli -a "$REDIS_PASSWORD" ping 2>/dev/null | grep -q "PONG"; then
            echo "‚úÖ Redis connection successful!"
            
            # Test Redis data operations
            RANDOM_VALUE=$RANDOM
            docker exec $REDIS_CONTAINER_ID redis-cli -a "$REDIS_PASSWORD" set test_key "$RANDOM_VALUE" > /dev/null
            RETRIEVED_VALUE=$(docker exec $REDIS_CONTAINER_ID redis-cli -a "$REDIS_PASSWORD" get test_key)
            if [ "$RETRIEVED_VALUE" = "$RANDOM_VALUE" ]; then
              echo "‚úÖ Redis data operations test passed"
            else
              echo "‚ö†Ô∏è Redis data operations test failed: Values don't match"
            fi
          else
            echo "‚ö†Ô∏è Redis connection failed with password from .env file"
            
            # Fallback: check if Redis is at least listening properly
            if docker exec $REDIS_CONTAINER_ID netstat -tuln | grep -q ":6379"; then
              echo "üîÑ Redis is listening on port 6379 but authentication failed"
              echo "üîç Debug information:"
              docker exec $REDIS_CONTAINER_ID cat /etc/redis.conf | grep -v -E '^#|^$' || true
              docker exec $REDIS_CONTAINER_ID env | grep REDIS || true
            else
              echo "‚ùå Redis is not listening on the expected port"
              exit 1
            fi
          fi

      - name: Test Adminer container
        run: |
          ADMINER_CONTAINER_ID=$(docker ps -q --filter "name=adminer")
          if [ -z "$ADMINER_CONTAINER_ID" ]; then
            echo "‚ùå Adminer container is not running"
            exit 1
          fi
          
          echo "‚úÖ Adminer container is running"
          
          # Check health status (if available)
          HEALTH_STATUS=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}not-supported{{end}}' $ADMINER_CONTAINER_ID)
          if [ "$HEALTH_STATUS" != "not-supported" ] && [ "$HEALTH_STATUS" != "healthy" ]; then
            echo "‚ö†Ô∏è Adminer container has unhealthy status: $HEALTH_STATUS"
          else
            echo "‚úÖ Adminer health check passed"
          fi
          
          # Check for PHP process (may be php, php-fpm, or php-fpm7)
          if ! docker exec $ADMINER_CONTAINER_ID ps aux | grep -E 'php|php-fpm' > /dev/null; then
            echo "‚ùå PHP process is not running in Adminer container"
            docker exec $ADMINER_CONTAINER_ID ps aux
            exit 1
          fi
          
          echo "‚úÖ PHP process is running in Adminer container"

      - name: Test FTP container
        run: |
          FTP_CONTAINER_ID=$(docker ps -q --filter "name=ftp")
          if [ -z "$FTP_CONTAINER_ID" ]; then
            echo "‚ùå FTP container is not running"
            exit 1
          fi
          
          echo "‚úÖ FTP container is running"
          
          # Check health status (if available)
          HEALTH_STATUS=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}not-supported{{end}}' $FTP_CONTAINER_ID)
          if [ "$HEALTH_STATUS" != "not-supported" ] && [ "$HEALTH_STATUS" != "healthy" ]; then
            echo "‚ö†Ô∏è FTP container has unhealthy status: $HEALTH_STATUS"
          else
            echo "‚úÖ FTP health check passed"
          fi
          
          # Check if vsftpd is running
          if ! docker exec $FTP_CONTAINER_ID pgrep vsftpd > /dev/null; then
            echo "‚ùå vsftpd process is not running in FTP container"
            exit 1
          fi
          
          echo "‚úÖ vsftpd process is running"
          
          # Check if FTP server is listening on port 21
          if ! docker exec $FTP_CONTAINER_ID sh -c "netstat -tuln | grep -q ':21.*LISTEN'"; then
            echo "‚ùå FTP container is not listening on port 21"
            docker exec $FTP_CONTAINER_ID netstat -tuln || true
            exit 1
          fi
          
          echo "‚úÖ FTP server is listening on port 21"
          
          # FTP simple connection test
          # (Skip actual connection test as it requires special network setup in GitHub Actions)
          echo "‚ÑπÔ∏è Skipping FTP connection test as it requires special network setup in GitHub Actions"

      - name: Test Portainer container
        run: |
          PORTAINER_CONTAINER_ID=$(docker ps -q --filter "name=portainer")
          if [ -z "$PORTAINER_CONTAINER_ID" ]; then
            echo "‚ùå Portainer container is not running"
            exit 1
          fi
          
          echo "‚úÖ Portainer container is running"
          
          # Check health status (if available)
          HEALTH_STATUS=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}not-supported{{end}}' $PORTAINER_CONTAINER_ID)
          if [ "$HEALTH_STATUS" != "not-supported" ] && [ "$HEALTH_STATUS" != "healthy" ]; then
            echo "‚ö†Ô∏è Portainer container has unhealthy status: $HEALTH_STATUS"
          else
            echo "‚úÖ Portainer health check passed"
          fi
          
          # Check if portainer process is running
          if ! docker exec $PORTAINER_CONTAINER_ID ps aux | grep -i portainer > /dev/null; then
            echo "‚ùå Portainer process is not running"
            docker exec $PORTAINER_CONTAINER_ID ps aux || true
            exit 1
          fi
          
          echo "‚úÖ Portainer process is running"
          
          # Check if Portainer is listening on port 9000
          if ! docker exec $PORTAINER_CONTAINER_ID sh -c "netstat -tuln | grep -q ':9000.*LISTEN'"; then
            echo "‚ùå Portainer is not listening on port 9000"
            docker exec $PORTAINER_CONTAINER_ID netstat -tuln || true
            exit 1
          fi
          
          echo "‚úÖ Portainer is listening on port 9000"

      - name: Tests completed
        run: |
          echo "üéâ All container tests completed!"
          echo "Container status summary:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

      - name: Stop containers
        run: |
          # Find docker-compose.yml file
          COMPOSE_FILE=$(find . -type f -name "docker-compose.yml" | head -1)
          
          if [ -n "$COMPOSE_FILE" ]; then
            echo "Stopping containers with docker compose"
            docker compose -f "$COMPOSE_FILE" down -v
          else
            echo "Stopping all containers"
            docker stop $(docker ps -q) || true
            docker rm $(docker ps -aq) || true
          fi
        if: always()